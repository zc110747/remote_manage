################################################################################
# This file is used to define global command, no need update the file unless 
# want to extend the global command.
#
################################################################################

echo "Update the Alias Command..."

#-------------------------------------------------------------------------------
# This section defines the alias of the command.
# The command abbreviation for use.
#-------------------------------------------------------------------------------
alias ll="ls -alF"
alias pe="printenv"
alias se="saveenv"

alias cdr="cd $ENV_PATH_ROOT"
alias cdk="cd $ENV_KERNEL_DIR"
alias cdu="cd $ENV_BOOT_DIR"
alias cdf="cd $ENV_ROOTFS_DIR"
alias cdl="cd $ENV_PATH_LOWER_APP"
alias cdn="cd $NFS_PATH"
alias cdlm="cd $ENV_PATH_LOWER_APP_MANAGE"
alias cdls="cd $ENV_PATH_LOWER_APP_SERVER"

#-------------------------------------------------------------------------------
# This section defines the function for program management.
# The Extend Command for program compiler, package, push.
#-------------------------------------------------------------------------------
function SysBuildApplication()
{
	echo frimware path:$ENV_PATH_ROOT
	echo kernal dir:$ENV_KERNEL_DIR

	#asio库以压缩包形式进行上传,首次使用需要解压
	if [ ! -d "$ENV_PATH_LOWER_APP_MANAGE/lib/asio" ]; then
		cd $ENV_PATH_LOWER_APP_MANAGE/lib/
		tar -xvf asio.tar.bz2
		echo "create asio library for manage sucess"
	else
		echo "already exist asio, can build"
	fi

	#编译驱动地址
	cd $ENV_PATH_ROOT
	if [ -d "$ENV_KERNEL_DIR" ]; then
		echo "start bulid kernal driver"
		cd $ENV_PATH_KERNAL_MOD/led/
		make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-
		mv kernal_led.ko ../../package/driver/
		make clean

		cd $ENV_PATH_KERNAL_MOD/beep/
		make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-
		mv kernal_beep.ko ../../package/driver/
		make clean

		cd $ENV_PATH_KERNAL_MOD/i2c_ap/
		make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-
		mv kernal_i2c_ap.ko ../../package/driver/
		make clean

		cd $ENV_PATH_KERNAL_MOD/spi_icm/
		make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-
		mv kernal_spi_icm.ko ../../package/driver/
		make clean

		cd $ENV_PATH_KERNAL_MOD/key/
		make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-
		mv kernal_key.ko ../../package/driver/
		make clean
	else
		echo "without linux kernal, not build kernal module"
	fi

	#覆盖配置文件
	cp -f $ENV_PATH_PACKAGE/config.json $ENV_PATH_LOWER_APP_MANAGE/config.json
	cp -f $ENV_PATH_PACKAGE/version.json $ENV_PATH_LOWER_APP_MANAGE/version.json
	cp -f $ENV_PATH_PACKAGE/config.json $ENV_PATH_LOWER_APP_SERVER/config.json
	cp -f $ENV_PATH_PACKAGE/version.json $ENV_PATH_LOWER_APP_SERVER/version.json

	#编译程序
	cd $ENV_PATH_LOWER_APP_MANAGE
	make -j4
	cd $ENV_PATH_ROOT
	cp lower_app/Executables/app_demo package/

	#打包服务器程序(包含node的后台和前端页面),拷贝到输出目录
	cd lower_app/
	tar -vcjf server.tar.bz2 server/ 
	cd ../
	mv lower_app/server.tar.bz2 package/

	#压缩完整包
	cd package/
	tar -vcjf remote_manage_v$FMWARE_VESRION.tar.bz2 *
	rm server.tar.bz2

	#clear the nfs run and copy new code
	rm -rf $NFS_RUN_PATH/*
	cd $ENV_PATH_ROOT
	cp package/app_demo $NFS_RUN_PATH/
	cp package/config.json $NFS_RUN_PATH/
	cp package/startApp $NFS_RUN_PATH/
	cp package/SysUpdate $NFS_RUN_PATH/
	cp -rf package/driver/ $NFS_RUN_PATH/
	cp -rf lower_app/server/ $NFS_RUN_PATH/

	#回到项目的地址
	cdr
}

alias SysBuildApplication='SysBuildApplication'

#推送项目到嵌入式软件端
function SysPushFirmware
{
	echo filepath:$ENV_PATH_PACKAGE, ipaddress:$EMBED_DEVICE_IPADDRESS
	scp -r $ENV_PATH_PACKAGE/remote_manage_v$FMWARE_VESRION.tar.bz2 root@$EMBED_DEVICE_IPADDRESS:/tmp/
}
alias SysPushFirmware='SysPushFirmware'

function SysCleanFirmware
{
	rm $ENV_PATH_PACKAGE/remote_manage_v$FMWARE_VESRION.tar.bz2
	cd $ENV_PATH_LOWER_APP_MANAGE
	make clean

	#回到项目的地址
	cdr
}
alias SysCleanFirmware='SysCleanFirmware'

function SysExecuteFirmware
{
	$ENV_PATH_PACKAGE/app_demo -f $ENV_PATH_PACKAGE/config.json
}
alias SysExecuteFirmware='SysExecuteFirmware'

function SysKillFirmware
{
	pkill -9 app_demo
}
alias SysKillFirmware='SysKillFirmware'

#将数据写入到文件中
function SysUpdateConfig
{
	truncate -s 0 $ENV_CONFIG_FILE
	echo "$FIRMWARE_CURRENT_PLATFORMS">$ENV_CONFIG_FILE
	echo "$FMWARE_VESRION">>$ENV_CONFIG_FILE
	echo "$EMBED_DEVICE_IPADDRESS">>$ENV_CONFIG_FILE
	exec bash
}
alias SysUpdateConfig='SysUpdateConfig'

#设置嵌入式linux环境
function SysSetPlatformEmbedLinux
{
	export FIRMWARE_CURRENT_PLATFORMS="Embed-Linux"
	SysUpdateConfig
}
alias SysSetPlatformEmbedLinux='SysSetPlatformEmbedLinux'

#设置环境为linux
function SysSetPlatformLinux
{
	export FIRMWARE_CURRENT_PLATFORMS="Linux"
	SysUpdateConfig
}
alias SysSetPlatformLinux='SysSetPlatformLinux'

#设置远端设备ip
function SysSetRemoteIpAddress
{
	if [ $# -eq 1 ]; then
		export EMBED_DEVICE_IPADDRESS=$1
		echo "Set Remote IpAddress is $1"
		SysUpdateConfig
	else
		echo "one parameter about ipaddress need!"
	fi
}
alias SysSetRemoteIpAddress='SysSetRemoteIpAddress'

#设置fimware的版本号
function SysSetFirmwareVer
{
	if [ $# -eq 1 ]; then
		export FMWARE_VESRION=$1
		echo "Set Firmware Version is $1"
		SysUpdateConfig
	else
		echo "one parameter about firmware version need!"
	fi
}
alias SysSetFirmwareVer='SysSetFirmwareVer'

#compare linux keranl
function SysBuildKernal
{
	cd $ENV_KERNEL_DIR
	make V=1 ARCH=arm CROSS_COMPILE=$KERNAL_CC all -j4

	cp -avf $ENV_KERNAL_ZIMAGE $TFTP_PATH/
	cp -avf $ENV_KERNAL_DTB $TFTP_PATH/
}
alias SysBuildKernal='SysBuildKernal'

function SysCleanKernal
{
	cd $ENV_KERNEL_DIR
	make distclean
	make ARCH=arm CROSS_COMPILE=$KERNAL_CC imx_v7_defconfig
}
alias SysCleanKernal='SysCleanKernal'

function SysBuildUboot
{
	cd $ENV_BOOT_DIR
	make V=1 ARCH=arm CROSS_COMPILE=$KERNAL_CC all -j4

	cp -avf u-boot.imx $TFTP_PATH/
}
alias SysBuildUboot='SysBuildUboot'

function SysCleanUboot
{
	cd $ENV_BOOT_DIR
	make distclean
	make ARCH=arm CROSS_COMPILE=$KERNAL_CC mx6ull_14x14_evk_emmc_defconfig
}
alias SysCleanUboot='SysCleanUboot'

function SysBuildRootfs
{
	cd $ENV_ROOTFS_DIR/busybox
	make&&make install

	cp -ravf $ENV_ROOTFS_DIR/_install/* $NFS_PATH/
	cd $GCC_LIB/lib

	cp -ravf *so* *.a $NFS_PATH/lib/
	cd $GCC_LIB/libc/lib
	cp -ravf *so* *.a $NFS_PATH/lib/
}
alias SysBuildRootfs='SysBuildRootfs'

function SysCleanRootfs
{
	cd $ENV_ROOTFS_DIR
	make clean
}
alias SysCleanRootfs='SysCleanRootfs'

function SysPackageFirmware
{
	if [ ! -d $DST_PATH ]; then
		mkdir $DST_PATH 
	fi

	cd $TFTP_PATH
	cp -rvf * $DST_PATH/
	
	cd $DST_PATH/
	mv u-boot.imx $ENV_KERNAL_BIN

	cd $NFS_PATH
	rm -rf rootfs.tar.bz2 
	tar -vcjf rootfs.tar.bz2 *
	mv rootfs.tar.bz2 $DST_PATH/

	echo "PackFirmware Success, you can find firmware in directory:"
	echo "$DST_PATH/"
}
alias SysPackageFirmware='SysPackageFirmware'

#显示帮助信息
function SysHelpCommand
{
	echo 'SysBuildApplication'
	echo '    Build Application, Package Firmware.'
	echo 'SysBuildKernal'
	echo '    Build the Kernal, if exist directory'
	echo 'SysSetPlatformEmbedLinux'
	echo '    Set Current Platform to Embed-Linux Complier'
	echo 'SysSetPlatformLinux'
	echo '    Set Current Platform to Linux Complier.'
	echo 'SysSetRemoteIpAddress'
	echo '    Set the remote ipaddress for command <SysPushFirmware>'
	echo 'SysSetFirmwareVer'
	echo '    Set the verison of the firmware when build'
	echo 'SysPushFirmware'
	echo '    Push firmware to remote embed device.'
	echo 'SysCleanFirmware'
	echo '    Clean firmware.'
	echo 'SysHelpCommand'
	echo '    Show the help command.'
}
alias SysHelpCommand='SysHelpCommand'

echo "Update the Alias Command Success!"